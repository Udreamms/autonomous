import { useState, useMemo } from 'react';
import { useDropzone } from 'react-dropzone';
import { toast } from 'sonner';
import { useFileUpload } from '@/lib/hooks/useFileUpload';
import { normalizePhoneNumber } from '@/lib/phoneUtils';
import { Timestamp } from 'firebase/firestore';
import { CardData, Message } from '../types';
import { socialPlatforms } from '../constants';

interface UseMessageSenderProps {
    currentCardId: string | null;
    currentGroupId: string | null;
    liveCardData: CardData | null;
    card: any; // Fallback card props
    setLiveCardData: React.Dispatch<React.SetStateAction<CardData | null>>;
    setForcedCardId: (id: string) => void;
    setForcedGroupId: (id: string) => void;
    activePlatform: string;
}

export const useMessageSender = ({
    currentCardId,
    currentGroupId,
    liveCardData,
    card,
    setLiveCardData,
    setForcedCardId,
    setForcedGroupId,
    activePlatform
}: UseMessageSenderProps) => {
    const [newMessage, setNewMessage] = useState('');
    const [isSending, setIsSending] = useState(false);
    const [selectedFile, setSelectedFile] = useState<File | null>(null);
    const [filePreviewUrl, setFilePreviewUrl] = useState<string | null>(null);

    const { uploading, progress, uploadFile } = useFileUpload();

    // 24h Window Check
    const isWithin24Hours = useMemo(() => {
        if (!liveCardData?.messages || liveCardData.messages.length === 0) return false;
        const userMessages = liveCardData.messages.filter(m => m.sender !== 'agent');
        if (userMessages.length === 0) return false;

        const lastUserMsg = userMessages[userMessages.length - 1];
        if (!lastUserMsg.timestamp) return false;

        const lastMsgDate = lastUserMsg.timestamp.toDate();
        const now = new Date();
        const diffHours = (now.getTime() - lastMsgDate.getTime()) / (1000 * 60 * 60);

        return diffHours < 24;
    }, [liveCardData?.messages]);

    const handleSendMessage = async () => {
        if (!newMessage.trim() || isSending) return;

        const rawPhone = liveCardData?.contactNumber || card?.contactNumber;
        const phoneNumber = normalizePhoneNumber(rawPhone || '');

        if (!phoneNumber) {
            toast.error('No se puede enviar: falta el número de teléfono del contacto.');
            return;
        }

        setIsSending(true);

        const tempMessage: Message = {
            text: newMessage,
            sender: 'agent',
            timestamp: Timestamp.now()
        };

        // 1. Optimistic UI Update
        setLiveCardData(prev => {
            if (!prev) return {
                ...card as any,
                id: currentCardId || 'temp',
                messages: [tempMessage]
            };
            return {
                ...prev,
                messages: [...(prev.messages || []), tempMessage]
            };
        });

        const messageToSend = newMessage;
        setNewMessage('');

        try {
            const apiCardId = currentCardId?.startsWith('temp-') ? undefined : currentCardId;

            let payload: any = {
                message: messageToSend,
                toNumber: phoneNumber,
                cardId: apiCardId,
                groupId: currentGroupId,
                platform: activePlatform // Add platform support if API supports it
            };

            // If outside 24h window (for WhatsApp specifically), send as Template
            // Note: Other platforms might not have this restriction or use different logic
            if (activePlatform === 'WhatsApp' && !isWithin24Hours) {
                payload = {
                    ...payload,
                    type: 'template',
                    template: {
                        name: 'custom_message',
                        language: { code: 'es' },
                        components: [
                            { type: 'body', parameters: [{ type: 'text', text: messageToSend }] }
                        ]
                    }
                };
            }

            // Using generic/WhatsApp endpoint for now - should be unified backend
            const response = await fetch('/api/whatsapp/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.suggestion || errorData.error || 'Failed to send');
            }

            const result = await response.json();

            if (result.success) {
                toast.success(`Mensaje enviado a ${result.sentTo}`);
            } else {
                throw new Error('API returned non-success response');
            }

            if (result.cardId && result.groupId) {
                if (result.cardId !== currentCardId || result.groupId !== currentGroupId) {
                    setForcedGroupId(result.groupId);
                    setForcedCardId(result.cardId);
                }
            }

        } catch (error: any) {
            console.error('Error sending message:', error);
            const msg = typeof error === 'string' ? error : error.message || 'Error al enviar el mensaje.';
            toast.error(msg);

            // Rollback
            setLiveCardData(prev => {
                if (!prev) return null;
                return {
                    ...prev,
                    messages: prev.messages?.filter(m => m !== tempMessage)
                };
            });
            setNewMessage(messageToSend);
        } finally {
            setIsSending(false);
        }
    };

    const sendTemplateMessage = async (templateName: string = 'hello_world') => {
        const rawPhone = liveCardData?.contactNumber || card?.contactNumber;
        const phoneNumber = normalizePhoneNumber(rawPhone || '');

        if (!phoneNumber) {
            toast.error('No se puede enviar: falta el número de teléfono.');
            return;
        }

        setIsSending(true);
        const tempMsg: Message = {
            text: `[PLANTILLA] ${templateName}`,
            sender: 'agent',
            timestamp: Timestamp.now()
        };

        setLiveCardData(prev => {
            if (!prev) return { ...card as any, id: currentCardId || 'temp', messages: [tempMsg] };
            return { ...prev, messages: [...(prev.messages || []), tempMsg] };
        });

        try {
            const response = await fetch('/api/whatsapp/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: `Plantilla enviada: ${templateName}`,
                    toNumber: phoneNumber,
                    cardId: currentCardId?.startsWith('temp-') ? undefined : currentCardId,
                    groupId: currentGroupId,
                    type: 'template',
                    template: { name: templateName, language: { code: templateName === 'hello_world' ? 'en_US' : 'es' } }
                })
            });

            if (!response.ok) throw new Error(JSON.stringify(await response.json()));

            const result = await response.json();
            if (result.success) {
                toast.success('Plantilla enviada correctamente');
                if (result.cardId && result.groupId) {
                    setForcedGroupId(result.groupId);
                    setForcedCardId(result.cardId);
                }
            }
        } catch (error: any) {
            toast.error('Error al enviar plantilla');
            setLiveCardData(prev => prev ? ({ ...prev, messages: prev.messages?.filter(m => m !== tempMsg) }) : null);
        } finally {
            setIsSending(false);
        }
    };

    const handleDisplayFileSend = async () => {
        if (!selectedFile || !liveCardData?.contactNumber) return;
        if (!currentCardId || currentCardId.startsWith('temp-')) {
            toast.error('Envía un mensaje de texto primero para iniciar la conversación.');
            return;
        }
        await uploadFile(selectedFile, { cardId: currentCardId, groupId: currentGroupId!, toNumber: liveCardData.contactNumber });
        if (filePreviewUrl) URL.revokeObjectURL(filePreviewUrl);
        setSelectedFile(null);
        setFilePreviewUrl(null);
    };

    const onDrop = (acceptedFiles: File[]) => {
        const file = acceptedFiles[0];
        if (file) {
            setSelectedFile(file);
            setFilePreviewUrl(URL.createObjectURL(file));
        }
    };

    const { getRootProps, getInputProps, isDragActive, open } = useDropzone({
        onDrop,
        accept: {
            'image/*': [],
            'video/*': [],
            'application/pdf': [],
            'audio/*': []
        },
        multiple: false
    });

    const handleCancelPreview = () => {
        setSelectedFile(null);
        setFilePreviewUrl(null);
    };

    return {
        newMessage,
        setNewMessage,
        isSending,
        selectedFile,
        filePreviewUrl,
        setSelectedFile,
        setFilePreviewUrl,
        uploading,
        progress,
        isWithin24Hours,
        handleSendMessage,
        sendTemplateMessage,
        handleDisplayFileSend,
        handleCancelPreview,
        open,
        getRootProps,
        getInputProps,
        isDragActive
    };
};
